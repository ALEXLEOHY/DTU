---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by alex.
--- DateTime: 2023/7/25 13:48
---
local mRegData = ""
local mHeartData = ""
local mHeartTime = 0
local rxbuf = zbuff.create(8192)
local tid
local reconnect = 3000
function tcpConstruct(server_ip, server_port, tcp_udp, regData, heartData, heartTime)

    print("测试数据tcpConstruct", regData, heartData, heartTime)
    if regData ~= "" and regData ~= nil then
        mRegData = regData
        print("mRegData mobile.imei()", mRegData)
    end
    if heartData ~= "" and heartData ~= nil then
        mHeartData = heartData
    end

    if heartTime ~= "" and heartTime ~= nil then
        mHeartTime = tonumber(heartTime)
    end
    initsocketTask(server_ip, server_port, tcp_udp)
end

function netCB(netc, event, param)
    if param ~= 0 then
        sys.publish("socket_disconnect")
        return
    end
    if event == socket.LINK then
    elseif event == socket.ON_LINE then
        -- 创建一个循环定时器
        tid = sys.timerLoopStart(function()
            log.info("发送tcp心跳,数据为", mHeartData)
            if mNetc then
                socket.tx(mNetc, mHeartData)
            end
        end, mHeartTime * 1000)

        log.info("发送注册包", mRegData)
        socket.tx(netc, mRegData)
        gpio.set(30, 0)
        tcpConnect = true
    elseif event == socket.EVENT then
        socket.rx(netc, rxbuf)
        socket.wait(netc)
        if rxbuf:used() > 0 then
            log.info("tcp收到", rxbuf:toStr(0, rxbuf:used()))
            uartSend(rxbuf:toStr(0, rxbuf:used()))
        end
        rxbuf:del()
    elseif event == socket.TX_OK then
        socket.wait(netc)
        log.info("tcp发送完成")
    elseif event == socket.CLOSE then
        sys.publish("socket_disconnect")
    end
end

function initsocketTask(server_ip, server_port, tcp_udp)
    local netc = socket.create(socket.LWIP_GP, netCB)
    mNetc = netc
    socket.debug(netc, true)
    --  p3, udp/tcp
    socket.config(netc, nil, tcp_udp, false, 300, 5, 6)  --开启TCP保活，防止长时间无数据交互被运营商断线
    while true do
        local succ, result = socket.connect(netc, server_ip, server_port)

        if not succ then
            log.info("未知错误，",reconnect,"毫秒后重连")
        else
            local result, msg = sys.waitUntil("socket_disconnect")
            log.info("socket_disconnect")
        end
        if tid ~= nil then
            sys.timerStop(tid)
        end
        tcpConnect = false
        gpio.set(30, 1)
        log.info("服务器断开了",reconnect,"毫秒后重连")
        socket.close(netc)
        log.info(rtos.meminfo("sys"))
        sys.wait(reconnect)
        exponentialBack()
    end
end

function sendHeatData()
    log.info("发送tcp心跳,数据为", mHeartData)
    if mNetc then
        socket.tx(mNetc, mHeartData)
    end
end

-- 处理串口数据发送给tcp
function socketSend(uartData)
    log.info("发送给tcp", uartData)
    if mNetc then
        socket.tx(mNetc, uartData)
    end
end

function exponentialBack(reconnectSecond)
    if  reconnect > 50000 then
        pm.reboot()
    end
    reconnect = reconnect+10000

end
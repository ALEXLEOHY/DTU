---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by alex.
--- DateTime: 2023/6/28 15:34
---
require("config")
require("keyWord")
require("mqttmodule")
-- 根据实际设备选取不同的uartId
uartId = 1
local baud_rate = 9600
local data_bits = 8
local stop_bits = 1
local checkDigit = uart.NONE

function initUart()
    local baudRateConf = fdb.kv_get(uartKeyWords.baudRate)
    if baudRateConf then
        baud_rate = baudRateConf
    end
    local dataBitsConf = fdb.kv_get(uartKeyWords.dataBit)
    if dataBitsConf then
        data_bits = dataBitsConf
    else
        data_bits = 8
    end
    local stopBitsConf = fdb.kv_get("stopBits")
    if stopBitsConf then
        stop_bits = stopBitsConf
    else
        stop_bits = 1
    end
    local checkDigitConf = fdb.kv_get("checkDigit")
    if checkDigitConf == 1 then
        checkDigit = uart.NONE
    elseif checkDigitConf == 2 then
        checkDigit = uart.EVEN
    elseif checkDigitConf == 3 then
        checkDigit = uart.ODD
    end

    -- 初始化串口
    log.info("初始化串口", "波特率", baud_rate, "数据位", data_bits, "停止位", stop_bits, "校验位", checkDigit)
    local result = uart.setup(uartId, -- 串口id
            baud_rate, -- 波特率
            data_bits, -- 数据位
            stop_bits, -- 停止位
            checkDigit --校验位，可选 uart.None/uart.Even/uart.Odd
    )
    if result then
        -- 注册串口数据回调
        -- 收取数据会触发回调, 这里的"receive" 是固定值
        uart.on(uartId, "receive", function(id, len)

            local s = ""
            repeat
                -- 如果是air302, len不可信, 传1024
                -- s = uart.read(id, 1024)
                s = uart.read(id, len)
                if #s > 0 then
                    -- #s 是取字符串的长度
                    -- 如果传输二进制/十六进制数据, 部分字符不可见, 不代表没收到
                    -- 关于收发hex值,请查阅 https://doc.openluat.com/article/583

                    print(s:toHex())
                    print(s)
                    log.info("uart", "receive", id, #s, s:toHex(), s)

                    handleUart(#s, s, s:toHex())

                end
            until s == ""
        end)

        -- 并非所有设备都支持sent事件
        uart.on(uartId, "sent", function(id)
            log.info("串口发送成功", "sent", id)
        end)
    end
    return result
end

-- 处理串口数据
function handleUart(count, uartData, uartHexData)
    local FFData = string.rep("FF", count)
    print("FFData", FFData)
    print("count", count)
    print("uartData", uartHexData)
    if FFData ~= uartHexData then
        --取出数据区
        local uartJsonData = string.sub(uartHexData, 1, #uartHexData - 4)
        uartStringData = string.fromHex(uartJsonData)

        if string.find(uartStringData, "ddkConfigRead") then
            log.info("配置数据")
            --检查crc
            local modbus_crc_data = pack.pack('<h', crypto.crc16("MODBUS", uartData))
            log.info("checkModbusCrc16", tostring(modbus_crc_data:toHex()))

            -- 判断crc校验是否通过
            if tostring(modbus_crc_data:toHex()) == "0000" then
                log.info("crc校验通过")
                local checkUartData = json.decode(string.fromHex(uartJsonData))

                if checkUartData.ddkConfigRead == false then
                    log.info("写入指令模式")
                    saveConfig(checkUartData)

                elseif checkUartData.ddkConfigRead == true then
                    log.info("读取指令模式")
                    readConfig()
                else
                    log.info("json数据直接转发")
                    dataToNet(uartHexData)
                end
            else
                --crc校验失败返回给串口
                dataToNet(uartData)
            end
        else
            --非配置数据直接转发
            dataToNet(uartData)
        end
    end


end

function uartSend(data)
    uart.write(uartId, data)
    sys.taskInit(receiveDataGpio)
end
--string
function uartSendCrc(data)

    local crcData = pack.pack('<h', crypto.crc16("MODBUS", data))
    if crcData then
        print("串口数据发送HEXcrc", data:toHex(), crcData:toHex())
        print("串口数据发送crc", data .. crcData)
        uart.write(uartId, data .. crcData)
    end
    sys.taskInit(receiveDataGpio)
end

function dataToNet(data)

    sys.taskInit(sendDataGpio)
    local mode = fdb.kv_get("mode")
    if mode == 1 then
        handleUartToMqtt(data)
    elseif mode == 2 then
        handleUartToTcp(data)
    elseif mode == nil then
        handleUartToTestMqtt(data)
    end
end

function receiveDataGpio()
    gpio.set(29, 1)
    sys.wait(700)
    gpio.set(29, 0)
    sys.wait(100)
    gpio.set(29, 1)
    sys.wait(100)
    gpio.set(29, 0)
    sys.wait(100)
    gpio.set(29, 1)
end

function sendDataGpio()
    gpio.set(29, 1)
    sys.wait(900)
    gpio.set(29, 0)
    sys.wait(100)
    gpio.set(29, 1)
end